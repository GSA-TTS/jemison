// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package work_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getGuestbookEntries = `-- name: GetGuestbookEntries :many
SELECT path, next_fetch FROM guestbook 
WHERE 
  host = $1
`

type GetGuestbookEntriesRow struct {
	Path      string      `json:"path"`
	NextFetch pgtype.Date `json:"next_fetch"`
}

// Returns all the entries for a host
func (q *Queries) GetGuestbookEntries(ctx context.Context, host int64) ([]GetGuestbookEntriesRow, error) {
	rows, err := q.db.Query(ctx, getGuestbookEntries, host)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGuestbookEntriesRow
	for rows.Next() {
		var i GetGuestbookEntriesRow
		if err := rows.Scan(&i.Path, &i.NextFetch); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuestbookEntry = `-- name: GetGuestbookEntry :one
SELECT id, scheme, host, path, content_sha1, content_length, content_type, last_updated, last_fetched, next_fetch FROM guestbook 
WHERE 
  host = $1 
  AND
  path = $2
  LIMIT 1
`

type GetGuestbookEntryParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// Returns a single guestbook entry
// based on the unique host/path combo.
func (q *Queries) GetGuestbookEntry(ctx context.Context, arg GetGuestbookEntryParams) (Guestbook, error) {
	row := q.db.QueryRow(ctx, getGuestbookEntry, arg.Host, arg.Path)
	var i Guestbook
	err := row.Scan(
		&i.ID,
		&i.Scheme,
		&i.Host,
		&i.Path,
		&i.ContentSha1,
		&i.ContentLength,
		&i.ContentType,
		&i.LastUpdated,
		&i.LastFetched,
		&i.NextFetch,
	)
	return i, err
}

const getHostId = `-- name: GetHostId :one
SELECT id FROM hosts WHERE host = $1
`

// Find a host ID
func (q *Queries) GetHostId(ctx context.Context, host pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getHostId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setLastFetchedToYesterday = `-- name: SetLastFetchedToYesterday :one
INSERT INTO guestbook
  (host, path, next_fetch)
  VALUES ($1, $2, NOW()+make_interval(days => -1))
  ON CONFLICT (host, path)
  WHERE host = $1 AND path = $1
  DO UPDATE
    SET
      next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type SetLastFetchedToYesterdayParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// In order to crawl a site out of the normal schedule, we will want to
// rewrite when those pages were last fetched. We do this for a full domain.
func (q *Queries) SetLastFetchedToYesterday(ctx context.Context, arg SetLastFetchedToYesterdayParams) (int64, error) {
	row := q.db.QueryRow(ctx, setLastFetchedToYesterday, arg.Host, arg.Path)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const toFetchOrNotToFetch = `-- name: ToFetchOrNotToFetch :one
SELECT 
  CASE
    -- Deadline passed
    WHEN host = $1 AND path = $2 AND next_fetch < NOW() THEN 2
    -- Deadline not yet reached
    WHEN host = $1 AND path = $2 AND next_fetch >= NOW() THEN 1
    -- If we can't find the path, then this is not found
    ELSE 3
  END AS is_past_next_fetch
  FROM guestbook
  WHERE host = $1 AND path = $2
`

type ToFetchOrNotToFetchParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// If it is time to fetch?
// These match a Golang enum.
// const (
//
//	NotPreviouslySeen FetchStatus = iota
//	DeadlineNotYetReached
//	DeadlinePassed
//	NotFound
//	HallPass
//	DefaultCase
//
// )
func (q *Queries) ToFetchOrNotToFetch(ctx context.Context, arg ToFetchOrNotToFetchParams) (int32, error) {
	row := q.db.QueryRow(ctx, toFetchOrNotToFetch, arg.Host, arg.Path)
	var is_past_next_fetch int32
	err := row.Scan(&is_past_next_fetch)
	return is_past_next_fetch, err
}

const updateNextFetch = `-- name: UpdateNextFetch :one
INSERT INTO guestbook
  (scheme, host, path, last_fetched, next_fetch)
  VALUES ($2, $3, $4, NOW(),
  (SELECT
    CASE 
      WHEN $1 = 'weekly' THEN NOW()+make_interval(weeks => 1, days => -1)
      WHEN $1 = 'monthly' THEN NOW()+make_interval(months => 1, days => -1)
      WHEN $1 = 'bi-monthly' THEN NOW()+make_interval(months => 2, days => -1)
      WHEN $1 = 'quarterly' THEN NOW()+make_interval(months=> 3, days => -1)
    END)
  )
  ON CONFLICT (host, path) 
  WHERE host = $3 AND path = $4
  DO UPDATE 
    SET 
      next_fetch = EXCLUDED.next_fetch,
      last_fetched = NOW()
  RETURNING id
`

type UpdateNextFetchParams struct {
	Column1 interface{} `json:"column_1"`
	Scheme  interface{} `json:"scheme"`
	Host    int64       `json:"host"`
	Path    string      `json:"path"`
}

// Update the next fetch time based on our schedule
func (q *Queries) UpdateNextFetch(ctx context.Context, arg UpdateNextFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateNextFetch,
		arg.Column1,
		arg.Scheme,
		arg.Host,
		arg.Path,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertUniqueHost = `-- name: UpsertUniqueHost :one
INSERT INTO hosts 
  (host) 
  VALUES ($1)
  -- See https://stackoverflow.com/a/37543015
  -- This is a workaround; it forces the ` + "`" + `id` + "`" + ` to be 
  -- returned in all cases.
  ON CONFLICT (host) DO UPDATE
    SET host = EXCLUDED.host
  RETURNING id
`

// This gets used at startup. We walk the config
// file and load the table with unique hosts, so that
// we can use the IDs in the `guestbook` table.
func (q *Queries) UpsertUniqueHost(ctx context.Context, host pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, upsertUniqueHost, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}
