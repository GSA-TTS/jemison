// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package work_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getGuestbookEntries = `-- name: GetGuestbookEntries :many
SELECT path FROM guestbook 
WHERE 
  host = $1
`

// Returns all the entries for a host
func (q *Queries) GetGuestbookEntries(ctx context.Context, host int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGuestbookEntries, host)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuestbookEntry = `-- name: GetGuestbookEntry :one
SELECT id, scheme, host, path, content_sha1, content_length, content_type, last_updated, last_fetched FROM guestbook 
WHERE 
  host = $1 
  AND
  path = $2
  LIMIT 1
`

type GetGuestbookEntryParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// Returns a single guestbook entry
// based on the unique host/path combo.
func (q *Queries) GetGuestbookEntry(ctx context.Context, arg GetGuestbookEntryParams) (Guestbook, error) {
	row := q.db.QueryRow(ctx, getGuestbookEntry, arg.Host, arg.Path)
	var i Guestbook
	err := row.Scan(
		&i.ID,
		&i.Scheme,
		&i.Host,
		&i.Path,
		&i.ContentSha1,
		&i.ContentLength,
		&i.ContentType,
		&i.LastUpdated,
		&i.LastFetched,
	)
	return i, err
}

const getHostId = `-- name: GetHostId :one
SELECT id FROM hosts WHERE host = $1
`

// Find a host ID
func (q *Queries) GetHostId(ctx context.Context, host string) (int64, error) {
	row := q.db.QueryRow(ctx, getHostId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getHostNextFetch = `-- name: GetHostNextFetch :one
SELECT next_fetch from hosts WHERE id = $1
`

func (q *Queries) GetHostNextFetch(ctx context.Context, id int64) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getHostNextFetch, id)
	var next_fetch pgtype.Timestamp
	err := row.Scan(&next_fetch)
	return next_fetch, err
}

const setNextFetchToYesterday = `-- name: SetNextFetchToYesterday :one
INSERT INTO hosts
  (host, next_fetch)
  VALUES ($1, NOW()+make_interval(days => -1))
  ON CONFLICT (host)
  WHERE host = $1
  DO UPDATE
    SET 
      host = EXCLUDED.host,
      next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

func (q *Queries) SetNextFetchToYesterday(ctx context.Context, host string) (int64, error) {
	row := q.db.QueryRow(ctx, setNextFetchToYesterday, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const toFetchOrNotToFetch = `-- name: ToFetchOrNotToFetch :one
SELECT 
  CASE
    -- Deadline passed
    WHEN host = $1 AND path = $2 AND next_fetch < NOW() THEN 2
    -- Deadline not yet reached
    WHEN host = $1 AND path = $2 AND next_fetch >= NOW() THEN 1
    -- If we can't find the path, then this is not found
    ELSE 3
  END AS is_past_next_fetch
  FROM guestbook
  WHERE host = $1 AND path = $2
`

type ToFetchOrNotToFetchParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// If it is time to fetch?
// These match a Golang enum.
// const (
//
//	NotPreviouslySeen FetchStatus = iota 0
//	DeadlineNotYetReached = 1
//	DeadlinePassed = 2
//	NotFound = 3
//	HallPass = 4
//	DefaultCase = 5
//
// )
func (q *Queries) ToFetchOrNotToFetch(ctx context.Context, arg ToFetchOrNotToFetchParams) (int32, error) {
	row := q.db.QueryRow(ctx, toFetchOrNotToFetch, arg.Host, arg.Path)
	var is_past_next_fetch int32
	err := row.Scan(&is_past_next_fetch)
	return is_past_next_fetch, err
}

const updateNextFetch = `-- name: UpdateNextFetch :one
INSERT INTO hosts
  (host, next_fetch)
  VALUES ($2, 
  (SELECT
    CASE 
      WHEN $1 = 'weekly' THEN NOW()+make_interval(weeks => 1, days => -1)
      WHEN $1 = 'bi-weekly' THEN NOW()+make_interval(weeks => 2, days => -1)
      WHEN $1 = 'monthly' THEN NOW()+make_interval(months => 1, days => -1)
      WHEN $1 = 'bi-monthly' THEN NOW()+make_interval(months => 2, days => -1)
      WHEN $1 = 'quarterly' THEN NOW()+make_interval(months=> 3, days => -1)
    END)
  )
  ON CONFLICT (host)
  WHERE host = $2
  DO UPDATE
    SET 
      host = EXCLUDED.host,
      next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type UpdateNextFetchParams struct {
	Column1 interface{} `json:"column_1"`
	Host    string      `json:"host"`
}

func (q *Queries) UpdateNextFetch(ctx context.Context, arg UpdateNextFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateNextFetch, arg.Column1, arg.Host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertUniqueHost = `-- name: UpsertUniqueHost :one
INSERT INTO hosts 
  (host, next_fetch) 
  VALUES ($2, 
  (SELECT
    CASE 
      WHEN $1 = 'weekly' THEN NOW()+make_interval(weeks => 1, days => -1)
      WHEN $1 = 'bi-weekly' THEN NOW()+make_interval(weeks => 2, days => -1)
      WHEN $1 = 'monthly' THEN NOW()+make_interval(months => 1, days => -1)
      WHEN $1 = 'bi-monthly' THEN NOW()+make_interval(months => 2, days => -1)
      WHEN $1 = 'quarterly' THEN NOW()+make_interval(months=> 3, days => -1)
    END)
  )
  -- See https://stackoverflow.com/a/37543015
  -- This is a workaround; it forces the ` + "`" + `id` + "`" + ` to be 
  -- returned in all cases.
  ON CONFLICT (host) DO UPDATE
    SET host = EXCLUDED.host,
    next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type UpsertUniqueHostParams struct {
	Column1 interface{} `json:"column_1"`
	Host    string      `json:"host"`
}

// This gets used at startup. We walk the config
// file and load the table with unique hosts, so that
// we can use the IDs in the `guestbook` table.
func (q *Queries) UpsertUniqueHost(ctx context.Context, arg UpsertUniqueHostParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertUniqueHost, arg.Column1, arg.Host)
	var id int64
	err := row.Scan(&id)
	return id, err
}
