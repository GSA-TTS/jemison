// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package work_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkEntryExistsInGuestbook = `-- name: CheckEntryExistsInGuestbook :one
SELECT EXISTS(SELECT 1::bool FROM guestbook WHERE host = $1)
`

func (q *Queries) CheckEntryExistsInGuestbook(ctx context.Context, host int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkEntryExistsInGuestbook, host)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGuestbookEntries = `-- name: GetGuestbookEntries :many
SELECT path FROM guestbook 
WHERE 
  host = $1
`

// Returns all the entries for a host
func (q *Queries) GetGuestbookEntries(ctx context.Context, host int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGuestbookEntries, host)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuestbookEntry = `-- name: GetGuestbookEntry :one

  -- id BIGINT generated always as identity primary key,
  -- scheme scheme NOT NULL,
  -- host BIGINT references hosts(id) NOT NULL,
  -- path TEXT NOT NULL,
  -- content_sha1 TEXT,
  -- content_length INTEGER,
  -- content_type INTEGER references content_types(id),
  -- last_updated TIMESTAMP NOT NULL,
  -- last_fetched TIMESTAMP NOT NULL,
  -- next_fetch TIMESTAMP NOT NULL,
  -- UNIQUE (host, path)

SELECT id, scheme, host, path, content_sha1, content_length, content_type, last_updated, last_fetched, next_fetch FROM guestbook 
WHERE 
  host = $1 
  AND
  path = $2
  LIMIT 1
`

type GetGuestbookEntryParams struct {
	Host int64  `json:"host"`
	Path string `json:"path"`
}

// ------------------------------------------------------------
// `guestbook` table
// ------------------------------------------------------------
// Returns a single guestbook entry
// based on the unique host/path combo.
func (q *Queries) GetGuestbookEntry(ctx context.Context, arg GetGuestbookEntryParams) (Guestbook, error) {
	row := q.db.QueryRow(ctx, getGuestbookEntry, arg.Host, arg.Path)
	var i Guestbook
	err := row.Scan(
		&i.ID,
		&i.Scheme,
		&i.Host,
		&i.Path,
		&i.ContentSha1,
		&i.ContentLength,
		&i.ContentType,
		&i.LastUpdated,
		&i.LastFetched,
		&i.NextFetch,
	)
	return i, err
}

const getHostId = `-- name: GetHostId :one
SELECT id FROM hosts WHERE host = $1
`

// ------------------------------------------------------------
// `host` table
// ------------------------------------------------------------
// Find a host ID
func (q *Queries) GetHostId(ctx context.Context, host string) (int64, error) {
	row := q.db.QueryRow(ctx, getHostId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getHostNextFetch = `-- name: GetHostNextFetch :one
SELECT next_fetch from hosts WHERE id = $1
`

func (q *Queries) GetHostNextFetch(ctx context.Context, id int64) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getHostNextFetch, id)
	var next_fetch pgtype.Timestamp
	err := row.Scan(&next_fetch)
	return next_fetch, err
}

const setGuestbookFetchToYesterdayForHost = `-- name: SetGuestbookFetchToYesterdayForHost :exec
UPDATE guestbook
  SET 
    next_fetch = NOW()+make_interval(days => -1)
  WHERE
    host = $1
`

func (q *Queries) SetGuestbookFetchToYesterdayForHost(ctx context.Context, host int64) error {
	_, err := q.db.Exec(ctx, setGuestbookFetchToYesterdayForHost, host)
	return err
}

const setHostNextFetchToYesterday = `-- name: SetHostNextFetchToYesterday :exec
UPDATE hosts
  SET
    next_fetch = NOW()+make_interval(days => -1)
  WHERE
    host = $1
`

func (q *Queries) SetHostNextFetchToYesterday(ctx context.Context, host string) error {
	_, err := q.db.Exec(ctx, setHostNextFetchToYesterday, host)
	return err
}

const updateGuestbookFetch = `-- name: UpdateGuestbookFetch :one
INSERT INTO guestbook
  -- 1       2     3        4             5               6             7            -              8
  (scheme, host, path, content_sha1, content_length, content_type, last_updated, last_fetched, next_fetch)
  VALUES 
  -- always insert three seconds in the past
  -- this way, if we check too fast, we're guaranteed to see
  -- that we last fetched it in the past.
  ($1, $2, $3, $4, $5, $6, $7, NOW()+make_interval(secs => -3), $8)
  ON CONFLICT (host, path) DO UPDATE
  SET
    scheme = EXCLUDED.scheme,
    host = EXCLUDED.host,
    path = EXCLUDED.path,
    content_sha1 = COALESCE($4, EXCLUDED.content_sha1),
    content_length = COALESCE($5, EXCLUDED.content_length),
    content_type = COALESCE($6, EXCLUDED.content_type),
    last_updated = EXCLUDED.last_updated,
    last_fetched = EXCLUDED.last_fetched,
    next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type UpdateGuestbookFetchParams struct {
	Scheme        string           `json:"scheme"`
	Host          int64            `json:"host"`
	Path          string           `json:"path"`
	ContentSha1   pgtype.Text      `json:"content_sha1"`
	ContentLength pgtype.Int4      `json:"content_length"`
	ContentType   pgtype.Text      `json:"content_type"`
	LastUpdated   pgtype.Timestamp `json:"last_updated"`
	NextFetch     pgtype.Timestamp `json:"next_fetch"`
}

// This is likely called by `fetch`
func (q *Queries) UpdateGuestbookFetch(ctx context.Context, arg UpdateGuestbookFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateGuestbookFetch,
		arg.Scheme,
		arg.Host,
		arg.Path,
		arg.ContentSha1,
		arg.ContentLength,
		arg.ContentType,
		arg.LastUpdated,
		arg.NextFetch,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateHostNextFetch = `-- name: UpdateHostNextFetch :one
  --   CASE 
  --     WHEN $1::TEXT = 'weekly' THEN NOW()+make_interval(weeks => 1, days => -1)
  --     WHEN $1 = 'bi-weekly' THEN NOW()+make_interval(weeks => 2, days => -1)
  --     WHEN $1 = 'monthly' THEN NOW()+make_interval(months => 1, days => -1)
  --     WHEN $1 = 'bi-monthly' THEN NOW()+make_interval(months => 2, days => -1)
  --     WHEN $1 = 'quarterly' THEN NOW()+make_interval(months=> 3, days => -1)
  --   END)
  -- )

INSERT INTO hosts
  (host, next_fetch)
  VALUES ($1, $2)
  ON CONFLICT (host)
  WHERE host = $1
  DO UPDATE
    SET 
      host = EXCLUDED.host,
      next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type UpdateHostNextFetchParams struct {
	Host      string           `json:"host"`
	NextFetch pgtype.Timestamp `json:"next_fetch"`
}

// (SELECT
// FIXM: This is the same as Upsert. Reduce to one function.
func (q *Queries) UpdateHostNextFetch(ctx context.Context, arg UpdateHostNextFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateHostNextFetch, arg.Host, arg.NextFetch)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertUniqueHost = `-- name: UpsertUniqueHost :one
INSERT INTO hosts 
  (host, next_fetch) 
  VALUES ($1, $2) 
  -- See https://stackoverflow.com/a/37543015
  -- This is a workaround; it forces the ` + "`" + `id` + "`" + ` to be 
  -- returned in all cases.
  ON CONFLICT (host) DO UPDATE
    SET host = EXCLUDED.host,
    next_fetch = EXCLUDED.next_fetch
  RETURNING id
`

type UpsertUniqueHostParams struct {
	Host      string           `json:"host"`
	NextFetch pgtype.Timestamp `json:"next_fetch"`
}

// This gets used at startup. We walk the config
// file and load the table with unique hosts, so that
// we can use the IDs in the `guestbook` table.
func (q *Queries) UpsertUniqueHost(ctx context.Context, arg UpsertUniqueHostParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertUniqueHost, arg.Host, arg.NextFetch)
	var id int64
	err := row.Scan(&id)
	return id, err
}
