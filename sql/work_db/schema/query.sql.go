// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package work_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkEntryExistsInGuestbook = `-- name: CheckEntryExistsInGuestbook :one
select exists(select 1::bool from guestbook where host = $1)
`

func (q *Queries) CheckEntryExistsInGuestbook(ctx context.Context, host int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkEntryExistsInGuestbook, host)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGuestbookEntries = `-- name: GetGuestbookEntries :many
select path from guestbook 
where 
  host = $1
`

// returns all the entries for a host
func (q *Queries) GetGuestbookEntries(ctx context.Context, host int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getGuestbookEntries, host)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuestbookEntry = `-- name: GetGuestbookEntry :one

  -- id bigint generated always as identity primary key,
  -- scheme scheme not null,
  -- host bigint references hosts(id) not null,
  -- path text not null,
  -- content_sha1 text,
  -- content_length integer,
  -- content_type integer references content_types(id),
  -- last_updated timestamp not null,
  -- last_fetched timestamp not null,
  -- next_fetch timestamp not null,
  -- unique (host, path)

select id, last_modified, last_fetched, next_fetch, scheme, host, content_type, content_length, path from guestbook 
where 
  host = $1 
  and
  path = $2
  limit 1
`

type GetGuestbookEntryParams struct {
	Host int32  `json:"host"`
	Path string `json:"path"`
}

// ------------------------------------------------------------
// `guestbook` table
// ------------------------------------------------------------
// returns a single guestbook entry
// based on the unique host/path combo.
func (q *Queries) GetGuestbookEntry(ctx context.Context, arg GetGuestbookEntryParams) (Guestbook, error) {
	row := q.db.QueryRow(ctx, getGuestbookEntry, arg.Host, arg.Path)
	var i Guestbook
	err := row.Scan(
		&i.ID,
		&i.LastModified,
		&i.LastFetched,
		&i.NextFetch,
		&i.Scheme,
		&i.Host,
		&i.ContentType,
		&i.ContentLength,
		&i.Path,
	)
	return i, err
}

const getHostId = `-- name: GetHostId :one
select id from hosts where host = $1
`

// ------------------------------------------------------------
// `host` table
// ------------------------------------------------------------
// find a host id
func (q *Queries) GetHostId(ctx context.Context, host pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getHostId, host)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getHostNextFetch = `-- name: GetHostNextFetch :one
select next_fetch from hosts where id = $1
`

func (q *Queries) GetHostNextFetch(ctx context.Context, id int64) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getHostNextFetch, id)
	var next_fetch pgtype.Timestamp
	err := row.Scan(&next_fetch)
	return next_fetch, err
}

const setGuestbookFetchToYesterdayForHost = `-- name: SetGuestbookFetchToYesterdayForHost :exec
update guestbook
  set 
    next_fetch = now()+make_interval(days => -1)
  where
    host = $1
`

func (q *Queries) SetGuestbookFetchToYesterdayForHost(ctx context.Context, host int32) error {
	_, err := q.db.Exec(ctx, setGuestbookFetchToYesterdayForHost, host)
	return err
}

const setHostNextFetchToYesterday = `-- name: SetHostNextFetchToYesterday :exec
update hosts
  set
    next_fetch = now()+make_interval(days => -1)
  where
    host = $1
`

func (q *Queries) SetHostNextFetchToYesterday(ctx context.Context, host pgtype.Text) error {
	_, err := q.db.Exec(ctx, setHostNextFetchToYesterday, host)
	return err
}

const updateGuestbookFetch = `-- name: UpdateGuestbookFetch :one
insert into guestbook
  -- 1       2     3        4
  (scheme, host, path, content_length, 
  --    5               6             7         8
  content_type, last_modified, last_fetched, next_fetch)
  values 
  -- always insert three seconds in the past
  -- this way, if we check too fast, we're guaranteed to see
  -- that we last fetched it in the past.
  ($1, $2, $3, $4, $5, $6, $7, $8)
  on conflict (host, path) do update
  set
    scheme = excluded.scheme,
    host = excluded.host,
    path = excluded.path,
    content_length = coalesce($4, excluded.content_length),
    content_type = coalesce($5, excluded.content_type),
    last_modified = coalesce(excluded.last_updated),
    last_fetched = now()+make_interval(secs => -3),
    next_fetch = excluded.next_fetch
  returning id
`

type UpdateGuestbookFetchParams struct {
	Scheme        int32            `json:"scheme"`
	Host          int32            `json:"host"`
	Path          string           `json:"path"`
	ContentLength int32            `json:"content_length"`
	ContentType   pgtype.Int4      `json:"content_type"`
	LastModified  pgtype.Timestamp `json:"last_modified"`
	LastFetched   pgtype.Timestamp `json:"last_fetched"`
	NextFetch     pgtype.Timestamp `json:"next_fetch"`
}

// this is likely called by `fetch`
func (q *Queries) UpdateGuestbookFetch(ctx context.Context, arg UpdateGuestbookFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateGuestbookFetch,
		arg.Scheme,
		arg.Host,
		arg.Path,
		arg.ContentLength,
		arg.ContentType,
		arg.LastModified,
		arg.LastFetched,
		arg.NextFetch,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateHostNextFetch = `-- name: UpdateHostNextFetch :one
  --   case 
  --     when $1::text = 'weekly' then now()+make_interval(weeks => 1, days => -1)
  --     when $1 = 'bi-weekly' then now()+make_interval(weeks => 2, days => -1)
  --     when $1 = 'monthly' then now()+make_interval(months => 1, days => -1)
  --     when $1 = 'bi-monthly' then now()+make_interval(months => 2, days => -1)
  --     when $1 = 'quarterly' then now()+make_interval(months=> 3, days => -1)
  --   end)
  -- )

insert into hosts
  (host, next_fetch)
  values ($1, $2)
  on conflict (host)
  where host = $1
  do update
    set 
      host = excluded.host,
      next_fetch = excluded.next_fetch
  returning id
`

type UpdateHostNextFetchParams struct {
	Host      pgtype.Text      `json:"host"`
	NextFetch pgtype.Timestamp `json:"next_fetch"`
}

// (select
// fixm: this is the same as upsert. reduce to one function.
func (q *Queries) UpdateHostNextFetch(ctx context.Context, arg UpdateHostNextFetchParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateHostNextFetch, arg.Host, arg.NextFetch)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertUniqueHost = `-- name: UpsertUniqueHost :one
insert into hosts 
  (host, next_fetch) 
  values ($1, $2) 
  -- see https://stackoverflow.com/a/37543015
  -- this is a workaround; it forces the ` + "`" + `id` + "`" + ` to be 
  -- returned in all cases.
  on conflict (host) do update
    set host = excluded.host,
    next_fetch = excluded.next_fetch
  returning id
`

type UpsertUniqueHostParams struct {
	Host      pgtype.Text      `json:"host"`
	NextFetch pgtype.Timestamp `json:"next_fetch"`
}

// this gets used at startup. we walk the config
// file and load the table with unique hosts, so that
// we can use the ids in the `guestbook` table.
func (q *Queries) UpsertUniqueHost(ctx context.Context, arg UpsertUniqueHostParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertUniqueHost, arg.Host, arg.NextFetch)
	var id int64
	err := row.Scan(&id)
	return id, err
}
